# Story 1.3: Parallel Bulk Greeks Processor Service

**Story ID**: 1.3  
**Epic**: Epic 1 - Foundation & Streaming Pipeline  
**Status**: Approved  
**Priority**: High  
**Estimated Effort**: 3-4 days  
**Created**: 2025-08-07  
**Approved**: 2025-08-07  

## User Story

**As a** system,  
**I want** to process bulk options Greeks data requests by expiration date in parallel,  
**So that** I can efficiently download all data while respecting API constraints.

## Context

Following the completion of Stories 1.1 and 1.2, we now have:
- Effect-TS project structure with service layers
- ThetaDataApiClient service with retry logic and error handling
- Health check functionality verifying Terminal connection
- Usage-level concurrency control pattern established
- Test framework with Live and Test layers

This story builds upon the client service to create an efficient parallel processing system for downloading options data organized by expiration dates.

## Acceptance Criteria

1. List all available expirations for the trade date
2. Create parallel processor using configured concurrency limit (2-4 requests)
3. Fetch bulk Greeks data for each expiration independently using getBulkOptionsGreeks
4. Add queue management for pending expirations
5. Create test scenarios with various concurrency configurations
6. Ensure proper error handling per expiration (one failure doesn't stop others)
7. Track metrics on processing times and success rates per expiration

## Technical Implementation Tasks

### TDD Workflow Order:
1. Define service interface first
2. Create test layer with mocked behavior
3. Write comprehensive tests
4. Implement Live layer to make tests pass

### Task 1: BulkGreeksProcessor Service Interface (AC: 1, 3)
- [ ] Define BulkGreeksProcessor service interface in `src/services/BulkGreeksProcessor.ts`
- [ ] Create Context.Tag for the service
- [ ] Define types for processing results and metrics
- [ ] Define error types specific to bulk processing

### Task 2: Expiration Filtering Logic (AC: 1)
- [ ] Implement method to filter expirations by trade date
- [ ] Add logic to calculate days to expiration (DTE)
- [ ] Support configurable max DTE limit from AppConfig
- [ ] Handle both 0DTE and future expirations

### Task 3: Test Layer Implementation (TDD Step 2)
- [ ] Create BulkGreeksProcessorTest in `src/layers/BulkGreeksProcessorTest.ts`
- [ ] Mock successful bulk Greeks fetching
- [ ] Mock partial failure scenarios
- [ ] Mock different data volumes per expiration
- [ ] Implement controllable delays for concurrency testing

### Task 4: Test Suite Creation (TDD Step 3)
- [ ] Write tests in `test/services/BulkGreeksProcessor.test.ts`
- [ ] Test with concurrency = 1 (sequential)
- [ ] Test with concurrency = 2 (parallel)
- [ ] Test with concurrency = 4 (max parallel)
- [ ] Test partial failure scenarios
- [ ] Test metrics collection accuracy

### Task 5: Parallel Processing Implementation (AC: 2, 3, 4)
- [ ] Create `processBulkGreeks` method that accepts array of expirations and trade date
- [ ] Use Effect.all with concurrency option for parallel processing
- [ ] Call getBulkOptionsGreeks for each expiration with proper parameters
- [ ] Ensure each expiration processes independently

### Task 6: Error Handling & Resilience (AC: 6)
- [ ] Implement per-expiration error isolation using Effect.either
- [ ] Add fallback mechanism for failed expirations
- [ ] Log errors with expiration context
- [ ] Create partial success result type

### Task 7: Metrics Collection (AC: 7)
- [ ] Track processing start/end time per expiration
- [ ] Count successful vs failed expirations
- [ ] Measure data volume (record count) per expiration
- [ ] Calculate average processing time
- [ ] Create ProcessingMetrics type with all metrics

### Task 8: Live Service Implementation (TDD Step 4)
- [ ] Create BulkGreeksProcessorLive in `src/layers/BulkGreeksProcessorLive.ts`
- [ ] Inject ThetaDataApiClient dependency
- [ ] Implement parallel processing with configurable concurrency
- [ ] Add progress tracking capability
- [ ] Ensure all unit tests pass

### Task 9: Integration Test Implementation
- [ ] Create `test/integration/BulkGreeksProcessorLive.integration.test.ts`
- [ ] Test with real ThetaData Terminal when THETA_DATA_TERMINAL_URL is set
- [ ] Test processing multiple real expirations in parallel
- [ ] Verify metrics accuracy with real data
- [ ] Test partial failure recovery with real API
- [ ] Include skip logic when Terminal not available
- [ ] Add clear instructions for running integration tests

### Task 10: Integration with CLI (Future Story Reference)
- [ ] Document interface for future CLI integration
- [ ] Define progress callback interface
- [ ] Create example usage patterns

## Dev Notes

### Architecture Context from Previous Stories

**Service Layer Pattern (from Story 1.1):**
- Use Effect Context.Tag for service definition
- Create Live and Test layer implementations
- Follow dependency injection pattern established

**ThetaData Integration (from Story 1.2):**
- ThetaDataApiClient provides `listExpirations()` and `getBulkOptionsGreeks()` methods
- Concurrency is controlled at usage level via Effect.all
- Default concurrency: 2, max: 4 (configurable via AppConfig)
- Each request has retry logic with exponential backoff built-in

**Key Implementation Details:**
```typescript
// From ThetaDataApiClient interface
listExpirations(): Effect.Effect<ReadonlyArray<ExpirationDate>, ...>
getBulkOptionsGreeks(params: BulkOptionsGreeksParams): Effect.Effect<ReadonlyArray<OptionsGreeksData>, ...>

// BulkOptionsGreeksParams for each expiration:
interface BulkOptionsGreeksParams {
  root: string           // 'SPXW'
  expiration: string     // YYYYMMDD format
  startDate: string      // Trade date in YYYYMMDD
  endDate: string        // Same as startDate for single day
  interval?: number      // Optional interval in ms
  rth?: boolean         // Regular trading hours flag
}

// ExpirationDate type includes:
interface ExpirationDate {
  date: string        // YYYY-MM-DD format
  daysToExpiration: number
}
```

**Project Structure:**
```
src/
  services/
    BulkGreeksProcessor.ts    # Service interface
  layers/
    BulkGreeksProcessorLive.ts # Live implementation
    BulkGreeksProcessorTest.ts # Test implementation
  models/
    ProcessingMetrics.ts      # Metrics types
test/
  services/
    BulkGreeksProcessor.test.ts  # Unit tests
  integration/
    BulkGreeksProcessorLive.integration.test.ts  # Integration tests
```

### Testing Standards

**Test Framework:** Bun test runner
**Test Locations:** 
- Unit tests: `test/services/BulkGreeksProcessor.test.ts`
- Integration tests: `test/integration/BulkGreeksProcessorLive.integration.test.ts`
**Coverage Target:** >90% for service implementation

**Test Patterns to Follow:**
- Use `describe` and `it` blocks for organization
- Test both success and failure scenarios
- Use Effect.runPromise for async tests
- Provide both Live and Test layer configurations
- Test concurrency behavior explicitly
- Integration tests should use `describe.skipIf(!SHOULD_RUN_INTEGRATION_TESTS)`

**Integration Test Pattern (from ThetaDataApiClientLive.integration.test.ts):**
```typescript
const SHOULD_RUN_INTEGRATION_TESTS = process.env.THETA_DATA_TERMINAL_URL !== undefined

describe.skipIf(!SHOULD_RUN_INTEGRATION_TESTS)('BulkGreeksProcessorLive Integration Tests', () => {
  it('should process real expirations in parallel', async () => {
    // Test with real Terminal connection
  })
})
```

**Example Unit Test Structure:**
```typescript
describe('BulkGreeksProcessor', () => {
  describe('processBulkGreeks', () => {
    it('should process multiple expirations in parallel', async () => {
      // Test implementation with mocked data
    })
  })
})
```

## Definition of Done

### Code Quality
- [ ] All TypeScript strict mode checks pass
- [ ] No ESLint/Biome warnings or errors
- [ ] Code follows patterns from Stories 1.1 and 1.2
- [ ] All exports properly indexed

### Testing
- [ ] Unit tests achieve >90% coverage
- [ ] All concurrency scenarios tested
- [ ] Error isolation verified
- [ ] Metrics accuracy validated
- [ ] Integration tests pass when Terminal available
- [ ] Integration tests properly skip when Terminal unavailable

### Documentation
- [ ] Service interface documented with JSDoc
- [ ] Usage examples provided
- [ ] Metrics structure documented
- [ ] Integration patterns documented

### Performance
- [ ] Respects configured concurrency limits
- [ ] Memory usage stable during processing
- [ ] Metrics collection has minimal overhead
- [ ] Partial failures don't block pipeline

## Dependencies & Risks

### Dependencies
- Story 1.1: Project Setup (✅ Complete)
- Story 1.2: ThetaData Client (✅ Complete)
- AppConfig service for configuration
- ThetaDataApiClient for data fetching

### Risks
- **Large Expiration Sets**: Many expirations could overwhelm queue
  - *Mitigation*: Implement batching if needed
- **Memory Usage**: Processing many expirations simultaneously
  - *Mitigation*: Concurrency limits, streaming in next story
- **Metric Overhead**: Tracking could impact performance
  - *Mitigation*: Lightweight metrics, optional detailed tracking

## Notes for Development

1. Start with the service interface to establish the contract
2. Use TDD approach - write tests first
3. Leverage Effect.all's built-in concurrency control
4. Keep metrics lightweight but informative
5. Ensure service remains generic for future data types beyond SPX
6. Consider adding a progress callback for UI integration

## Validation Checklist

Before marking complete:
- [ ] Can list and filter expirations by trade date
- [ ] Processes multiple expirations in parallel
- [ ] Respects concurrency configuration
- [ ] Handles partial failures gracefully
- [ ] Collects accurate metrics
- [ ] All unit tests pass
- [ ] Integration tests pass when Terminal available
- [ ] Integration tests skip properly when Terminal unavailable
- [ ] Documentation complete

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-07 | 1.0 | Initial story creation | Sarah (PO) |
| 2025-08-07 | 1.1 | Approved for development | Sarah (PO) |

## Dev Agent Record

*To be populated during development*

### Agent Model Used
*To be recorded*

### Debug Log References
*To be recorded*

### Completion Notes
*To be recorded*

### File List
*To be recorded*

## QA Results

*To be populated during QA review*